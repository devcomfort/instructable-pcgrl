<script lang="ts">
	import Icon from '$lib/icons/Icon.svelte';
	import type { ClassValue } from 'svelte/elements';
	import { twMerge } from 'tailwind-merge';
	import { instructions } from '$lib/store/preset/instructions';
	import { requestInference, type RequestFormat } from '$lib/core/inference';
	import { get, writable } from 'svelte/store';
	import { tick } from 'svelte';
	import { numberOfStep } from '$lib/store/editor/number-of-step';
	import { mapState } from '$lib/store/editor/map-state';

	const {
		placeholder = 'Type your message...',
		disabled = false,
		maxHeight = '200px',
		showMicrophone = true,
		initialMessages = [],
		class: className,
		systemMode = false
	} = $props<{
		placeholder?: string;
		disabled?: boolean;
		maxHeight?: string;
		showMicrophone?: boolean;
		initialMessages?: Array<{
			id: string;
			text: string;
			timestamp: Date;
			isUser: boolean;
		}>;
		class?: ClassValue;
		/**
		 * If true, removes the visual distinction between user and system messages.
		 * All messages will be left-aligned and use a gray background.
		 *
		 * ---
		 *
		 * If true, removes the visual distinction between user and system messages.
		 * All messages will be left-aligned and use a gray background.
		 */
		systemMode?: boolean;
	}>();

	// State management
	let messageInput: string = $state('');
	let textareaElement: HTMLTextAreaElement;
	let isRecording: boolean = $state(false);
	let suggestedMessages: string[] = $state([]);
	let isLoadingAPI: boolean = $state(false); // API loading state variable

	// Message history for chat display
	const messages: Array<{
		id: string;
		text: string;
		timestamp: Date;
		isUser: boolean;
	}> = $state([...initialMessages]);

	/**
	 * Select random suggested messages from instructions
	 * This runs once when the component is initialized.
	 *
	 * ---
	 *
	 * Select random suggested messages from instructions.
	 * This runs once when the component is initialized.
	 */
	$effect(() => {
		const shuffled = [...$instructions].sort(() => 0.5 - Math.random());
		suggestedMessages = shuffled.slice(0, 5);
	});

	/**
	 * Handle clicking on a suggested message
	 * Sets the message input to the suggested text and focuses the textarea.
	 *
	 * ---
	 *
	 * Handle clicking on a suggested message.
	 * Sets the message input to the suggested text and focuses the textarea.
	 */
	async function handleSuggestedMessageClick(suggestion: string) {
		messageInput = suggestion;
		await tick(); // Wait for DOM to update with the new messageInput value

		if (textareaElement) {
			textareaElement.focus();
			// Trigger input event manually to update textarea height
			handleInput(); // Now handleInput will use the updated textarea value
		}
	}

	/**
	 * Handle sending a message
	 * Validates input, adds to message history, and clears the input.
	 * Also handles API call and response.
	 *
	 * ---
	 *
	 * Handle sending a message.
	 * Validates input, adds to message history, and clears the input.
	 * Also handles API call and response.
	 */
	async function handleSendMessage() {
		const trimmedMessage = messageInput.trim();
		if (trimmedMessage && !disabled && !isLoadingAPI) {
			// Add user message to history
			messages.push({
				id: crypto.randomUUID(),
				text: trimmedMessage,
				timestamp: new Date(),
				isUser: true
			});

			isLoadingAPI = true;

			try {
				// 요청 데이터 생성
				const requestPayload: RequestFormat = {
					current_level: $mapState, // Use mapState store value
					step_count: $numberOfStep, // Use numberOfStep store value
					instruction: trimmedMessage
				};

				const startTime = performance.now(); // Record inference start time
				const response = await requestInference(requestPayload);
				const endTime = performance.now(); // Record inference end time
				const inferenceTimeSeconds = ((endTime - startTime) / 1000).toFixed(3); // Convert to seconds and format to 3 decimal places

				// Add AI inference time message
				messages.push({
					id: crypto.randomUUID(),
					text: `AI has generated the map. (Inference time: ${inferenceTimeSeconds}s)`,
					timestamp: new Date(),
					isUser: false
				});

				// mapState update logic
				const episodeKeys = Object.keys(response);
				if (episodeKeys.length > 0) {
					const firstEpisodeKey = episodeKeys[0];
					const firstEpisode = response[firstEpisodeKey];
					// Optional chaining
					const lastStateInEpisode = firstEpisode?.state?.[firstEpisode.state.length - 1];

					if (lastStateInEpisode) {
						mapState.set(lastStateInEpisode);
						console.log('[Chat] mapState updated with AI response:', lastStateInEpisode);
					} else {
						console.warn(
							'[Chat] Could not retrieve last state from first episode, mapState not updated.'
						);
					}
				} else {
					console.warn('[Chat] No episodes found in API response, mapState not updated.');
				}
			} catch (error) {
				console.error('[Chat] API request failed:', error);
				let errorMessage = 'An error occurred during the API request.';
				if (error instanceof Error) {
					errorMessage = error.message;
				}
				messages.push({
					id: crypto.randomUUID(),
					text: `Error: ${errorMessage}`,
					timestamp: new Date(),
					isUser: false
				});
			} finally {
				isLoadingAPI = false;
			}

			// TODO: Integrate with chat API or backend service
		}
	}

	/**
	 * Handle voice recording toggle
	 * Placeholder for future voice input functionality.
	 *
	 * ---
	 *
	 * Handle voice recording toggle.
	 * Placeholder for future voice input functionality.
	 */
	function handleMicrophoneToggle() {
		isRecording = !isRecording;

		// TODO: Implement speech recognition API integration
		if (isRecording) {
			console.log('[Chat] Starting voice recording...');
			// Future: Start speech recognition
		} else {
			console.log('[Chat] Stopping voice recording...');
			// Future: Stop speech recognition and process result
		}
	}

	/**
	 * Handle keyboard events in textarea
	 * Send message on Enter (without Shift) and manage textarea height.
	 *
	 * ---
	 *
	 * Handle keyboard events in textarea.
	 * Send message on Enter (without Shift) and manage textarea height.
	 */
	function handleKeydown(event: KeyboardEvent) {
		if (event.key === 'Enter' && !event.shiftKey) {
			event.preventDefault();
			handleSendMessage();
		}
	}

	/**
	 * Auto-resize textarea based on content
	 * Maintains smooth UX with dynamic height adjustment.
	 *
	 * ---
	 *
	 * Auto-resize textarea based on content.
	 * Maintains smooth UX with dynamic height adjustment.
	 */
	function handleInput() {
		if (textareaElement) {
			// Reset height to calculate new height
			textareaElement.style.height = 'auto';

			// Set new height based on scroll height, with max limit
			const newHeight = Math.min(textareaElement.scrollHeight, Number.parseInt(maxHeight));
			textareaElement.style.height = `${newHeight}px`;
		}
	}

	/**
	 * Reset textarea height to default
	 * Used after sending message to maintain consistent appearance.
	 *
	 * ---
	 *
	 * Reset textarea height to default.
	 * Used after sending message to maintain consistent appearance.
	 */
	function resetTextareaHeight() {
		if (textareaElement) {
			textareaElement.style.height = 'auto';
		}
	}

	/**
	 * Format timestamp for message display
	 * Returns human-readable time format.
	 *
	 * ---
	 *
	 * Format timestamp for message display.
	 * Returns human-readable time format.
	 */
	function formatTimestamp(timestamp: Date): string {
		return timestamp.toLocaleTimeString([], {
			hour: '2-digit',
			minute: '2-digit'
		});
	}
</script>

<!-- 
Chat component with modern UI design matching project style
Includes message history display and input area with voice recording capability
Input area features auto-resizing textarea and microphone toggle button

---

Chat component with modern UI design matching project style.
Includes message history display and input area with voice recording capability.
Input area features auto-resizing textarea and microphone toggle button.
-->
<div
	class={twMerge(
		'flex h-full w-[90vw] max-w-[90vw] flex-col rounded-lg border border-gray-300 bg-white shadow-sm md:w-[50vw] md:max-w-[50vw] lg:w-[30vw] lg:max-w-[30vw] xl:w-[20vw] xl:max-w-[20vw]',
		className
	)}
>
	<!-- Message History Area -->
	<div class="flex-1 overflow-y-auto p-4">
		{#if messages.length === 0}
			<!-- Empty state message -->
			<div class="flex h-full items-center justify-center text-gray-500">
				<div class="text-center">
					<p class="text-lg font-medium">Generate Maps with IPCGRL</p>
					<p class="mt-1 text-sm">Enter your instructions below to create a map.</p>
				</div>
			</div>
		{:else}
			<!-- Message list -->
			<div class="space-y-3">
				{#each messages as message (message.id)}
					<div
						class="flex {systemMode
							? 'justify-start'
							: message.isUser
								? 'justify-end'
								: 'justify-start'}"
					>
						<div
							class="break-words rounded-lg px-3 py-2 {systemMode
								? 'bg-gray-100 text-gray-900'
								: message.isUser
									? 'bg-blue-500 text-white'
									: 'bg-gray-100 text-gray-900'}"
						>
							<p class="text-sm">{message.text}</p>
							<p class="mt-1 text-xs opacity-70">
								{formatTimestamp(message.timestamp)}
							</p>
						</div>
					</div>
				{/each}
			</div>
		{/if}
	</div>

	<!-- Input Area -->
	<div class="border-t border-gray-200 bg-gray-50 p-4">
		<!-- Suggested Messages Area -->
		{#if suggestedMessages.length > 0 && !disabled}
			<div class="mb-2 flex flex-col items-start gap-2">
				{#each suggestedMessages as suggestion}
					<button
						type="button"
						class="max-w-xs whitespace-normal rounded-full bg-gray-200 px-3 py-1 text-left text-xs text-gray-700 hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50"
						onclick={() => handleSuggestedMessageClick(suggestion)}
					>
						{suggestion}
					</button>
				{/each}
			</div>
		{/if}

		<div class="flex items-end gap-2">
			<!-- Text Input with Auto-resize -->
			<div class="flex-1">
				<textarea
					bind:this={textareaElement}
					bind:value={messageInput}
					{placeholder}
					disabled={disabled || isLoadingAPI}
					rows="1"
					class="w-full resize-none rounded-lg border border-gray-300 bg-white px-3 py-2 text-sm focus:border-blue-500 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 disabled:bg-gray-100 disabled:text-gray-500"
					style="max-height: {maxHeight};"
					onkeydown={handleKeydown}
					oninput={handleInput}
				></textarea>
			</div>

			<!-- Voice Input Button -->
			{#if showMicrophone}
				<button
					type="button"
					class="flex items-center justify-center rounded-lg p-3 transition-all hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 disabled:cursor-not-allowed disabled:opacity-50 {isRecording
						? 'bg-red-100 text-red-600 hover:bg-red-200'
						: 'bg-white text-gray-600 shadow'}"
					onclick={handleMicrophoneToggle}
					disabled={disabled || isLoadingAPI}
					aria-label={isRecording ? 'Stop recording' : 'Start voice input'}
					title={isRecording ? 'Stop recording' : 'Start voice input'}
				>
					<Icon iconName="microphone" width={20} height={20} />
				</button>
			{/if}

			<!-- Send Button -->
			<button
				type="button"
				class="flex items-center justify-center rounded-lg bg-blue-500 p-3 text-white shadow transition-all hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50 disabled:cursor-not-allowed disabled:bg-gray-300"
				onclick={handleSendMessage}
				disabled={disabled || !messageInput.trim() || isLoadingAPI}
				aria-label="Send message"
				title="Send message"
			>
				<Icon iconName="send" width={20} height={20} />
			</button>
		</div>

		<!-- Recording Status Indicator / API Loading Indicator -->
		{#if isLoadingAPI}
			<div
				class="mt-2 flex items-center gap-2 text-sm text-blue-600"
				data-testid="loading-indicator"
			>
				<div class="h-2 w-2 animate-pulse rounded-full bg-blue-600"></div>
				<span>AI is generating...</span>
			</div>
		{:else if isRecording}
			<div
				class="mt-2 flex items-center gap-2 text-sm text-red-600"
				data-testid="recording-indicator"
			>
				<div class="h-2 w-2 animate-pulse rounded-full bg-red-600"></div>
				<span>Recording... (Feature coming soon)</span>
			</div>
		{/if}
	</div>
</div>
